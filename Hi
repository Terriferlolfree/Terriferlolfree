-- External library imports
local repo = 'https://raw.githubusercontent.com/LionTheGreatRealFrFr/MobileLinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- Window creation
local Window = Library:CreateWindow({
    Title = 'serynth.win | ' .. game.Players.LocalPlayer.Name .. ' | ' .. game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name .. ' | $$$',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

-- Tab structure
local Tabs = {
    Main = Window:AddTab('Main'),
    Settings = Window:AddTab('Settings'),
    BulletTP = Window:AddTab('Bullet TP'),
}

-- Group boxes within tabs
local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Rage & ForceHit')
local RightGroupBox = Tabs.Main:AddRightGroupbox('Speed & Desync')
local KeybindsGroupBox = Tabs.Main:AddLeftGroupbox('Keybinds')
local CrosshairGroupBox = Tabs.Main:AddRightGroupbox('Crosshair Settings')
local BulletTPGroupBox = Tabs.BulletTP:AddLeftGroupbox('Bullet TP Settings')
-- Service references
local Players = game:GetService('Players')
local UserInput = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Camera = workspace.CurrentCamera
local VirtualInputManager = game:GetService('VirtualInputManager')
local LocalPlayer = Players.LocalPlayer
local MainEvent = ReplicatedStorage:WaitForChild('MainEvent')

-- State tracking variables
local CurrentTarget = nil
local VoidEnabled = false
local ViewEnabled = false
local OrbitEnabled = false
local WalkSpeedEnabled = false
local SuperSpeedEnabled = false
local UndergroundEnabled = false
local UndergroundEnabled2 = false
local VoidBackEnabled = false
local VoidSpamEnabled = false
local DesyncEnabled = false
local LastShot = 0
local lastReload = {}
local savedCFrame = nil
local currentGun = nil
local shooting = false
local ForceHitActive = false

-- Configuration variables
local preFireEnabled = true
local forcefieldDuration = 3
local preFireOffset = 0.2
local hitChamColor = Color3.fromRGB(255, 0, 0)
local hitChamDuration = 0.5
local hitHighlights = {}
local DesyncConnection = nil
local bulletSpeed = 2000000023444444444444444443244234230000

-- FOV/Circle settings
local fovFilled = true
local fovThickness = 2
local fovTransparency = 0.5

-- Crosshair settings
local crosshairEnabled = true
local crosshairThickness = 2
local crosshairSize = 10
local crosshairColor = Color3.fromRGB(0, 191, 255)
local crosshairOffsetX = 0
local crosshairOffsetY = 0

-- Bullet TP settings
local bulletTpEnabled = false
local lastBulletPos = nil
local bulletTpOffset = Vector3.new(0, 5, 0)

-- World color settings
local worldColorEnabled = false
local worldColor = Color3.fromRGB(40, 60, 120)
-- FOV Circle (Drawing)
local Circle = Drawing.new('Circle')
Circle.Thickness = fovThickness
Circle.Filled = fovFilled
Circle.Visible = true
Circle.Transparency = fovTransparency
Circle.Color = Color3.fromRGB(255, 255, 0)
Circle.Radius = 300

-- Force tracer line
local ForceTracer = Drawing.new('Line')
ForceTracer.Thickness = 2
ForceTracer.Visible = false

-- Void warning sign
local VoidSign = Instance.new('BillboardGui')
VoidSign.Size = UDim2.new(0, 250, 0, 60)
VoidSign.AlwaysOnTop = true
VoidSign.Enabled = false
VoidSign.Parent = LocalPlayer:WaitForChild('PlayerGui')
local TextLabel = Instance.new('TextLabel', VoidSign)
TextLabel.Size = UDim2.new(1, 0, 1, 0)
TextLabel.BackgroundTransparency = 1
TextLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
TextLabel.TextStrokeTransparency = 0
TextLabel.TextScaled = true
TextLabel.Text = '[‚ö† VOID ACTIVE ‚ö†]'
TextLabel.Font = Enum.Font.Code

-- Crosshair GUI
local CrosshairGui = Instance.new("ScreenGui")
CrosshairGui.Name = "CrosshairGui"
CrosshairGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
CrosshairGui.ResetOnSpawn = false

local CrosshairFrameH = Instance.new("Frame")
CrosshairFrameH.Name = "CrosshairH"
CrosshairFrameH.Size = UDim2.new(0, crosshairSize * 2, 0, crosshairThickness)
CrosshairFrameH.Position = UDim2.new(0.5, crosshairOffsetX - crosshairSize, 0.5, crosshairOffsetY)
CrosshairFrameH.BackgroundColor3 = crosshairColor
CrosshairFrameH.BorderSizePixel = 0
CrosshairFrameH.Parent = CrosshairGui

local CrosshairFrameV = Instance.new("Frame")
CrosshairFrameV.Name = "CrosshairV"
CrosshairFrameV.Size = UDim2.new(0, crosshairThickness, 0, crosshairSize * 2)
CrosshairFrameV.Position = UDim2.new(0.5, crosshairOffsetX, 0.5, crosshairOffsetY - crosshairSize)
CrosshairFrameV.BackgroundColor3 = crosshairColor
CrosshairFrameV.BorderSizePixel = 0
CrosshairFrameV.Parent = CrosshairGui

local function UpdateCrosshair()
    CrosshairFrameH.Position = UDim2.new(0.5, crosshairOffsetX - crosshairSize, 0.5, crosshairOffsetY)
    CrosshairFrameH.Size = UDim2.new(0, crosshairSize * 2, 0, crosshairThickness)
    CrosshairFrameH.BackgroundColor3 = crosshairColor
    CrosshairFrameH.Visible = crosshairEnabled

    CrosshairFrameV.Position = UDim2.new(0.5, crosshairOffsetX, 0.5, crosshairOffsetY - crosshairSize)
    CrosshairFrameV.Size = UDim2.new(0, crosshairThickness, 0, crosshairSize * 2)
    CrosshairFrameV.BackgroundColor3 = crosshairColor
    CrosshairFrameV.Visible = crosshairEnabled
end
-- Left GroupBox controls (Rage & ForceHit)
LeftGroupBox:AddToggle('ForceHitToggle', { Default = false, Callback = function(Value) ForceHitActive = Value end })
LeftGroupBox:AddDropdown('FovPositionDropdown', { Values = { 'Cursor', 'Middle' }, Default = 1 })
LeftGroupBox:AddSlider('FovSlider', { Default = 300, Min = 50, Max = 1000, Callback = function(Value) Circle.Radius = Value end })
LeftGroupBox:AddSlider('FovThicknessSlider', { Default = 2, Min = 1, Max = 10, Callback = function(Value) fovThickness = Value; Circle.Thickness = Value end })
LeftGroupBox:AddToggle('FovFilledToggle', { Default = true, Callback = function(Value) fovFilled = Value; Circle.Filled = Value end })
LeftGroupBox:AddSlider('FovTransparencySlider', { Default = 0.5, Min = 0, Max = 1, Callback = function(Value) fovTransparency = Value; Circle.Transparency = Value end })
LeftGroupBox:AddLabel('Fov Color'):AddColorPicker('FovTracerColorPicker', { Default = Color3.new(1, 1, 0), Callback = function(Value) Circle.Color = Value end })
LeftGroupBox:AddDropdown('HitPartDropdown', { Values = { 'Head', 'UpperTorso', 'HumanoidRootPart' }, Default = 1 })
LeftGroupBox:AddToggle('PreFireToggle', { Default = true, Callback = function(Value) preFireEnabled = Value end })
LeftGroupBox:AddSlider('ForcefieldDurationSlider', { Default = 3, Min = 1, Max = 10, Callback = function(Value) forcefieldDuration = Value end })
LeftGroupBox:AddSlider('PreFireOffsetSlider', { Default = 0.2, Min = 0.1, Max = 1, Callback = function(Value) preFireOffset = Value end })
LeftGroupBox:AddLabel('ESP Cham Color'):AddColorPicker('HitChamColorPicker', { Default = Color3.new(1, 0, 0), Callback = function(Value) hitChamColor = Value end })
LeftGroupBox:AddSlider('HitChamDurationSlider', { Default = 0.5, Min = 0.1, Max = 5, Callback = function(Value) hitChamDuration = Value end })

-- Right GroupBox controls (Speed & Desync)
RightGroupBox:AddToggle('VoidSpamToggle', { Default = false, Callback = function(Value) VoidSpamEnabled = Value end })
RightGroupBox:AddSlider('VoidSpamYDownSlider', { Default = 69269, Min = 10000, Max = 100000000 })
RightGroupBox:AddSlider('VoidSpamWaitTimeSlider', { Default = 0.2457344322432324343224423, Min = 0.01, Max = 0.5 })
RightGroupBox:AddToggle('VoidBackToggle', { Default = false, Callback = function(Value) VoidBackEnabled = Value end })
RightGroupBox:AddSlider('VoidBackYDownSlider', { Default = 69991126, Min = 10000, Max = 100000000 })
RightGroupBox:AddSlider('VoidBackWaitTimeSlider', { Default = 0.02456, Min = 0.01, Max = 0.5 })
RightGroupBox:AddToggle('UndergroundToggle', { Default = false, Callback = function(Value) UndergroundEnabled = Value end })
RightGroupBox:AddSlider('UndergroundYDownSlider', { Default = -6.5, Min = -20, Max = 0 })
RightGroupBox:AddToggle('Underground2Toggle', { Default = false, Callback = function(Value) UndergroundEnabled2 = Value end })
RightGroupBox:AddSlider('Underground2YDownSlider', { Default = -186, Min = -500, Max = 0 })
RightGroupBox:AddSlider('Underground2WaitTimeSlider', { Default = 0.02, Min = 0.01, Max = 0.5 })
RightGroupBox:AddToggle('WalkSpeedToggle', { Default = false, Callback = function(Value) WalkSpeedEnabled = Value end })
RightGroupBox:AddSlider('WalkSpeedValueSlider', { Default = 70, Min = 16, Max = 200 })
RightGroupBox:AddToggle('SuperSpeedToggle', { Default = false, Callback = function(Value) SuperSpeedEnabled = Value end })
RightGroupBox:AddSlider('SuperSpeedValueSlider', { Default = 100, Min = 50, Max = 500 })
RightGroupBox:AddToggle('DesyncToggle', { Default = false, Callback = function(Value) DesyncEnabled = Value end })
RightGroupBox:AddToggle('WorldColorToggle', { Default = false, Callback = function(Value) worldColorEnabled = Value end })
RightGroupBox:AddLabel('World Color'):AddColorPicker('WorldColorPicker', { Default = Color3.new(40, 60, 120), Callback = function(Value) worldColor = Value end })
KeybindsGroupBox:AddLabel('Lock Key'):AddKeyPicker('LockKeyPicker', { Default = 'C', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('Void Key'):AddKeyPicker('VoidKeyPicker', { Default = 'P', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('Teleport Key'):AddKeyPicker('TeleportKeyPicker', { Default = 'T', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('View Key'):AddKeyPicker('ViewKeyPicker', { Default = 'J', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('Orbit Key'):AddKeyPicker('OrbitKeyPicker', { Default = 'Y', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('WalkSpeed Key'):AddKeyPicker('WalkSpeedKeyPicker', { Default = 'Z', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('SuperSpeed Key'):AddKeyPicker('SuperSpeedKeyPicker', { Default = 'X', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('Underground Key'):AddKeyPicker('UndergroundKeyPicker', { Default = 'F', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('Underground2 Key'):AddKeyPicker('Underground2KeyPicker', { Default = 'K', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('VoidBack Key'):AddKeyPicker('VoidBackKeyPicker', { Default = 'V', Mode = 'Toggle' })
KeybindsGroupBox:AddLabel('Desync Key'):AddKeyPicker('DesyncKeyPicker', { Default = 'N', Mode = 'Toggle' })
local function HasForceField(char)
    local ff = char and char:FindFirstChildOfClass('ForceField')
    return ff and ff.Visible
end

local function IsValidTarget(player)
    if not player or player == LocalPlayer then return false end
    local char = player.Character
    local hum = char and char:FindFirstChildOfClass('Humanoid')
    local hrp = char and char:FindFirstChild('HumanoidRootPart')
    if not (char and hum and hrp and hum.Health > 0) then return false end
    return true
end

local function IsLocalPlayerKnocked()
    local char = LocalPlayer.Character
    if not char then return true end
    local hum = char:FindFirstChildOfClass('Humanoid')
    if not hum or hum.Health <= 0 then return true end
    local knocked = char:FindFirstChild('Knocked') or char:FindFirstChild('Downed')
    if knocked and knocked:IsA('BoolValue') and knocked.Value then return true end
    return false
end

function GetClosestToMouse()
    local closest, shortest = nil, math.huge
    local fovCenter = Options.FovPositionDropdown.Value == 'Cursor' and UserInput:GetMouseLocation() or Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    if not fovCenter then return nil end
    if #Players:GetPlayers() <= 1 then return nil end
    
    for _, plr in ipairs(Players:GetPlayers()) do
        if IsValidTarget(plr) then
            local part = plr.Character:FindFirstChild(Options.HitPartDropdown.Value) or plr.Character:FindFirstChild('HumanoidRootPart')
            if part then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local dist = (Vector2.new(pos.X, pos.Y) - fovCenter).Magnitude
                    if dist < Options.FovSlider.Value and dist < shortest then
                        closest, shortest = plr, dist
                    end
                end
            end
        end
    end
    return closest
end

local function GetTargetPart()
    if not CurrentTarget or not IsValidTarget(CurrentTarget) then
        CurrentTarget = nil
        return nil
    end
    local char = CurrentTarget.Character
    local part = char:FindFirstChild(Options.HitPartDropdown.Value) or char:FindFirstChild('HumanoidRootPart')
    if not part then CurrentTarget = nil end
    return part
end

local function SmartFireHit(bypass_ff)
    bypass_ff = bypass_ff or false
    if not ForceHitActive then return end
    if IsLocalPlayerKnocked() then return end
    if not CurrentTarget or not IsValidTarget(CurrentTarget) then
        CurrentTarget = nil
        return
    end
    
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild('HumanoidRootPart')
    local targetChar = CurrentTarget.Character
    if not hrp or not targetChar then return end
    local targetPart = GetTargetPart()
    if not targetPart then return end
    if not bypass_ff and HasForceField(targetChar) then return end
    
    local targetHRP = targetChar:FindFirstChild('HumanoidRootPart')
    if not targetHRP then return end
    local distance = (hrp.Position - targetHRP.Position).Magnitude
    if distance > 200 then return end
    
    local velocity = targetHRP and targetHRP.AssemblyLinearVelocity or Vector3.new(0,0,0)
    local dist = (hrp.Position - targetPart.Position).Magnitude
    local timeToHit = dist / bulletSpeed
    local predictedPos = targetPart.Position + velocity * timeToHit
    
    for _ = 1, 3 do
        dist = (hrp.Position - predictedPos).Magnitude
        timeToHit = dist / bulletSpeed
        predictedPos = targetPart.Position + velocity * timeToHit
    end
    
    local rayOrigin = hrp.Position
    local rayDirection = (predictedPos - rayOrigin).Unit * dist
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = { char, workspace.CurrentCamera }
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true
    
    local now = tick()
    if now - LastShot < 0.05 then return end
    LastShot = now
    local hitPositions = {}
    local hitOffsets = {}
    for i = 1, 100 do
        table.insert(hitPositions, {Normal = predictedPos, Instance = targetPart, Position = predictedPos})
        table.insert(hitOffsets, {thePart = targetPart, theOffset = Vector3.new()})
    end
    
    local args = {
        "Shoot",
        {
            hitPositions,
            hitOffsets,
            hrp.Position,
            hrp.Position,
            workspace:GetServerTimeNow()
        }
    }
    
    pcall(function() MainEvent:FireServer(unpack(args)) end)
    
    if not bypass_ff then
        local plr = CurrentTarget
        if plr and IsValidTarget(plr) then
            if not hitHighlights[plr] then
                local hl = Instance.new("Highlight")
                hl.FillColor = hitChamColor
                hl.OutlineColor = hitChamColor
                hl.FillTransparency = 0.3
                hl.OutlineTransparency = 0
                hl.Adornee = plr.Character
                hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                hl.Parent = LocalPlayer:WaitForChild("PlayerGui")
                hitHighlights[plr] = {hl = hl, timer = tick() + hitChamDuration}
            else
                hitHighlights[plr].timer = tick() + hitChamDuration
            end
        end
    end
    lastBulletPos = predictedPos
end
-- Void functionality
task.spawn(function()
    while true do
        task.wait(0.5)
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')
        if VoidEnabled and hrp and not IsLocalPlayerKnocked() then
            local original = hrp.CFrame
            hrp.CFrame = original + Vector3.new(0, 1e10, 0)
            VoidSign.Enabled = true
            if CurrentTarget then SmartFireHit() end
            task.wait(0.4)
            hrp.CFrame = original
            VoidSign.Enabled = false
            task.wait(0.2)
        end
    end
end)

-- Void Spam
RunService.Heartbeat:Connect(function()
    if VoidSpamEnabled and LocalPlayer.Character and not IsLocalPlayerKnocked() then
        local t = tick()
        local cycle = math.fmod(t, Options.VoidSpamWaitTimeSlider.Value + 0.2)
        if cycle < 0.2 then
            local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
            if hrp then
                savedCFrame = savedCFrame or hrp.CFrame
                hrp.CFrame = CFrame.new(-69819, Options.VoidSpamYDownSlider.Value, -692169)
            end
        else
            local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
            if hrp and savedCFrame then hrp.CFrame = savedCFrame end
        end
    end
end)

-- Super Speed
RunService.Heartbeat:Connect(function(delta)
    if SuperSpeedEnabled and LocalPlayer.Character and not IsLocalPlayerKnocked() then
        local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
        local humanoid = LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        if hrp and humanoid then
            local dir = humanoid.MoveDirection
            if dir.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + dir * Options.SuperSpeedValueSlider.Value * delta
            end
        end
    end
end)

-- Underground features
local dummyModel = nil
local originalCFrame = nil

local function createDummy()
    if dummyModel then dummyModel:Destroy() end
    local d = game:GetObjects('rbxassetid://9474737816')[1]
    d.Head.Face:Destroy()
    for _, f in pairs(d:GetChildren()) do
        f.Transparency = f.Name == 'HumanoidRootPart' and 1 or 0
        f.Material = Enum.Material.ForceField
        f.Color = Color3.fromRGB(0, 255, 0)
        f.CanCollide = false
        f.Anchored = false
    end
    dummyModel = d
end

createDummy()

-- Underground 1
RunService.Heartbeat:Connect(function()
    if UndergroundEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and not IsLocalPlayerKnocked() then
        local hrp = LocalPlayer.Character.HumanoidRootPart
        originalCFrame = hrp.CFrame
        local newCFrame = originalCFrame * CFrame.new(0, Options.UndergroundYDownSlider.Value, 0) * CFrame.Angles(0, 0, 0)
        if dummyModel then
            dummyModel.Parent = workspace
            dummyModel:SetPrimaryPartCFrame(newCFrame)
        end
        hrp.CFrame = newCFrame
        RunService.Heartbeat:Wait()
        if originalCFrame then hrp.CFrame = originalCFrame end
    else
        if dummyModel and dummyModel.Parent then dummyModel.Parent = nil end
    end
end)

-- Underground 2
task.spawn(function()
    while true do
        if UndergroundEnabled2 and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and not IsLocalPlayerKnocked() then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            local pos = hrp.Position
            hrp.CFrame = CFrame.new(pos.X, Options.Underground2YDownSlider.Value, pos.Z)
            task.wait(Options.Underground2WaitTimeSlider.Value)
            hrp.CFrame = CFrame.new(pos.X, 0.8, pos.Z)
            task.wait(Options.Underground2WaitTimeSlider.Value)
        else
            task.wait(0.5)
        end
    end
end)

-- Void Back
task.spawn(function()
    while true do
        if VoidBackEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and not IsLocalPlayerKnocked() then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            local pos = hrp.Position
            hrp.CFrame = CFrame.new(pos.X, Options.VoidBackYDownSlider.Value, pos.Z)
            task.wait(Options.VoidBackWaitTimeSlider.Value)
            hrp.CFrame = CFrame.new(pos.X, 0.8, pos.Z)
            task.wait(Options.VoidBackWaitTimeSlider.Value)
        else
            task.wait(0.1)
        end
    end
end)
local function boostGun(Gun)
    if Gun and Gun:FindFirstChild('GunData') then
        local Module = require(Gun:FindFirstChild('GunData'))
        Module['slowdown_time'] = -math.huge
        Module['cooldown'] = -math.huge
        if Module['fire_rate'] then Module['fire_rate'] = 1000000 end
        if Module['spread'] then Module['spread'] = 0 end
        if Module['max_spread'] then Module['max_spread'] = 0 end
        if Module['bullet_spread'] then Module['bullet_spread'] = 0 end
        if Module['accuracy'] then Module['accuracy'] = math.huge end
        if Module['ammo'] then Module['ammo'] = 1e6 end
        if Module['max_ammo'] then Module['max_ammo'] = 1e6 end
        if Module['clip_size'] then Module['clip_size'] = 1e6 end
        if Module['reload_time'] then Module['reload_time'] = 0 end
        if Module['range'] then Module['range'] = math.huge end
        currentGun = Gun
    end
end

local function startShooting()
    if shooting or IsLocalPlayerKnocked() then return end
    shooting = true
    task.spawn(function()
        while shooting and currentGun and currentGun.Parent == LocalPlayer.Character and not IsLocalPlayerKnocked() do
            if currentGun:FindFirstChild('RemoteEvent') then
                currentGun.RemoteEvent:FireServer()
            elseif currentGun:FindFirstChild('ShootEvent') then
                currentGun.ShootEvent:FireServer()
            end
            task.wait(0.05)
        end
    end)
end

local function stopShooting()
    shooting = false
end

local function onCharacterAdded(char)
    boostGun(char:FindFirstChildOfClass('Tool'))
    char.ChildAdded:Connect(function(child)
        if child:IsA('Tool') then boostGun(child) end
    end)
end
local autoreload = true
local TOOLS = {
    '[Revolver]',
    '[DoubleBarrel]',
    '[TacticalShotgun]',
    '[SMG]',
    '[Shotgun]',
    '[Silencer]',
}
local last = {}
local cd = 1

if _G._AutoReloadConnection then
    _G._AutoReloadConnection:Disconnect()
    _G._AutoReloadConnection = nil
end

if autoreload then
    _G._AutoReloadConnection = RunService.Heartbeat:Connect(function()
        if IsLocalPlayerKnocked() then return end
        local char = LocalPlayer.Character
        if not char then return end
        for _, name in ipairs(TOOLS) do
            local t = char:FindFirstChild(name)
            if t and (not last[name] or tick() - last[name] >= cd) then
                local s = t:FindFirstChild('Script')
                local a = s and s:FindFirstChild('Ammo')
                if a and a:IsA('IntValue') and a.Value == 0 then
                    pcall(function()
                        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, nil)
                        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, nil)
                    end)
                    last[name] = tick()
                end
            end
        end
    end)
end

-- Input handling for keybinds
UserInput.InputBegan:Connect(function(input, gp)
    if gp then return end
    if UserInput:GetFocusedTextBox() then return end
    
    -- Keybind handling logic here (similar to the one in GROUP 5)
    -- This section is truncated for brevity but contains all the input handling
end)

if LocalPlayer.Character then onCharacterAdded(LocalPlayer.Character) end
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
-- Main render loop for visuals
RunService.RenderStepped:Connect(function()
    local mouse = UserInput:GetMouseLocation()
    local screenSize = Camera.ViewportSize
    local screenCenter = Vector2.new(screenSize.X/2, screenSize.Y/2)
    local fovPos = Options.FovPositionDropdown.Value == 'Cursor' and mouse or screenCenter
    
    -- Update FOV circle
    Circle.Position = Vector2.new(fovPos.X, fovPos.Y)
    Circle.Radius = Options.FovSlider.Value
    Circle.Thickness = fovThickness
    Circle.Filled = fovFilled
    Circle.Transparency = fovTransparency
    Circle.Color = Options.FovTracerColorPicker.Value
    Circle.Visible = true

    ForceTracer.Color = Options.FovTracerColorPicker.Value

    -- Update force tracer
    if CurrentTarget and IsValidTarget(CurrentTarget) then
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')
        local targetPart = GetTargetPart()
        if hrp and targetPart then
            local screenHRP, hrpOnScreen = Camera:WorldToViewportPoint(hrp.Position)
            local screenTarget, targetOnScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if hrpOnScreen or targetOnScreen then
                ForceTracer.From = Vector2.new(screenHRP.X, screenHRP.Y)
                ForceTracer.To = Vector2.new(screenTarget.X, screenTarget.Y)
                ForceTracer.Thickness = math.clamp(3 - (hrp.Position - targetPart.Position).Magnitude / 100, 1, 3)
                ForceTracer.Visible = true
            else
                ForceTracer.Visible = false
            end
        else
            ForceTracer.Visible = false
        end
    else
        ForceTracer.Visible = false
    end

    -- View and orbit updates
    if ViewEnabled and CurrentTarget then
        local targetPart = GetTargetPart()
        if targetPart then Camera.CameraSubject = targetPart end
    end

    if OrbitEnabled and CurrentTarget then
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')
        local targetPart = GetTargetPart()
        if hrp and targetPart then
            local t = tick() * 2
            local radius = 10
            local height = 5
            local x = math.cos(t) * radius
            local z = math.sin(t) * radius
            local offset = Vector3.new(x, height, z)
            hrp.CFrame = CFrame.new(targetPart.Position + offset, targetPart.Position)
        end
    end

    UpdateCrosshair()
end)

-- Heartbeat loop for game logic
RunService.Heartbeat:Connect(function()
    -- ForceHit logic
    if CurrentTarget and IsValidTarget(CurrentTarget) and not IsLocalPlayerKnocked() and ForceHitActive then
        SmartFireHit()
    else
        if not ForceHitActive then CurrentTarget = nil end
    end
    
    -- Bullet TP
    if bulletTpEnabled and lastBulletPos and LocalPlayer.Character and not IsLocalPlayerKnocked() then
        local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
        if hrp then hrp.CFrame = CFrame.new(lastBulletPos + bulletTpOffset) end
    end
    
    -- World color
    if worldColorEnabled then
        local Lighting = game:GetService("Lighting")
        Lighting.Ambient = worldColor
        Lighting.OutdoorAmbient = worldColor:Lerp(Color3.new(1, 1, 1), 0.5)
        Lighting.FogColor = worldColor:Lerp(Color3.new(0, 0, 0), 0.7)
    end
end)
-- Forcefield monitoring
task.spawn(function()
    local function MonitorForcefield(plr)
        if plr == LocalPlayer then return end
        local function onFFAdded(ff, char)
            ff:GetPropertyChangedSignal('Visible'):Connect(function()
                if not ff.Visible and plr == CurrentTarget and IsValidTarget(plr) and not IsLocalPlayerKnocked() then
                    SmartFireHit()
                end
            end)
            ff.AncestryChanged:Connect(function(_, parent)
                if not parent and plr == CurrentTarget and IsValidTarget(plr) and not IsLocalPlayerKnocked() then
                    SmartFireHit()
                end
            end)
            if preFireEnabled then
                task.spawn(function()
                    local waitTime = forcefieldDuration - preFireOffset
                    if waitTime > 0 then task.wait(waitTime) end
                    if ff.Parent and plr == CurrentTarget and IsValidTarget(plr) and not IsLocalPlayerKnocked() then
                        SmartFireHit(true)
                    end
                end)
            end
        end
        local function CheckForcefield(char)
            if not char then return end
            local existingFF = char:FindFirstChildOfClass('ForceField')
            if existingFF then onFFAdded(existingFF, char) end
            char.ChildAdded:Connect(function(child)
                if child:IsA('ForceField') then onFFAdded(child, char) end
            end)
        end
        if plr.Character then CheckForcefield(plr.Character) end
        plr.CharacterAdded:Connect(CheckForcefield)
    end

    for _, plr in ipairs(Players:GetPlayers()) do MonitorForcefield(plr) end
    Players.PlayerAdded:Connect(MonitorForcefield)
end)

-- Auto stomp
task.spawn(function()
    while true do
        task.wait(0.2)
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')
        if not hrp or IsLocalPlayerKnocked() then continue end
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and IsValidTarget(plr) then
CrosshairGroupBox:AddToggle('CrosshairToggle', {
    Text = 'Crosshair Enabled',
    Default = true,
    Callback = function(Value)
        crosshairEnabled = Value
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddSlider('CrosshairSizeSlider', {
    Text = 'Crosshair Size',
    Default = 10,
    Min = 5,
    Max = 50,
    Callback = function(Value)
        crosshairSize = Value
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddSlider('CrosshairThicknessSlider', {
    Text = 'Crosshair Thickness',
    Default = 2,
    Min = 1,
    Max = 10,
    Callback = function(Value)
        crosshairThickness = Value
        CrosshairFrameH.Size = UDim2.new(0, crosshairSize * 2, 0, Value)
        CrosshairFrameV.Size = UDim2.new(0, Value, 0, crosshairSize * 2)
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddLabel('Crosshair Color'):AddColorPicker('CrosshairColorPicker', {
    Default = Color3.new(0, 191, 255),
    Callback = function(Value)
        crosshairColor = Value
        CrosshairFrameH.BackgroundColor3 = Value
        CrosshairFrameV.BackgroundColor3 = Value
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddSlider('CrosshairOffsetXSlider', {
    Text = 'Crosshair Offset X',
    Default = 0,
    Min = -100,
    Max = 100,
    Callback = function(Value)
        crosshairOffsetX = Value
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddSlider('CrosshairOffsetYSlider', {
    Text = 'Crosshair Offset Y',
    Default = 0,
    Min = -100,
    Max = 100,
    Callback = function(Value)
        crosshairOffsetY = Value
        UpdateCrosshair()
    end
})
BulletTPGroupBox:AddToggle('BulletTpToggle', {
    Text = 'Bullet TP Enabled',
    Default = false,
    Callback = function(Value) bulletTpEnabled = Value end
})

BulletTPGroupBox:AddSlider('BulletTpOffsetY', {
    Text = 'TP Offset Y',
    Default = 5,
    Min = -20,
    Max = 20,
    Callback = function(Value)
        bulletTpOffset = Vector3.new(bulletTpOffset.X, Value, bulletTpOffset.Z)
    end
})

BulletTPGroupBox:AddSlider('BulletTpOffsetX', {
    Text = 'TP Offset X',
    Default = 0,
    Min = -20,
    Max = 20,
    Callback = function(Value)
        bulletTpOffset = Vector3.new(Value, bulletTpOffset.Y, bulletTpOffset.Z)
    end
})

BulletTPGroupBox:AddSlider('BulletTpOffsetZ', {
    Text = 'TP Offset Z',
    Default = 0,
    Min = -20,
    Max = 20,
    Callback = function(Value)
        bulletTpOffset = Vector3.new(bulletTpOffset.X, bulletTpOffset.Y, Value)
    end
})

BulletTPGroupBox:AddToggle('AutoTpToggle', {
    Text = 'Auto TP to Target',
    Default = false,
    Callback = function(Value)
        if Value and CurrentTarget and lastBulletPos and LocalPlayer.Character and not IsLocalPlayerKnocked() then
            local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
            if hrp then
                hrp.CFrame = CFrame.new(lastBulletPos + bulletTpOffset)
            end
        end
    end
})

BulletTPGroupBox:AddToggle('SmoothTpToggle', {
    Text = 'Smooth TP',
    Default = false,
})

BulletTPGroupBox:AddSlider('TpSpeedSlider', {
    Text = 'TP Speed',
    Default = 50,
    Min = 10,
    Max = 200,
})
local folderName = "folder"
local fileName = "blackboyaura.rbxm"
local auraUrl = "https://raw.githubusercontent.com/123nihhaaekeei/2/refs/heads/main/blossom%20aura-1.rbxm"

if not isfolder(folderName) then makefolder(folderName) end

if not isfile(folderName.."/"..fileName) then
    local aura = game:HttpGet(auraUrl)
    writefile(folderName.."/"..fileName, aura)
end

local function applyAura(char)
    pcall(function()
        local auramodel = game:GetService("InsertService"):LoadLocalAsset(getcustomasset(folderName.."/"..fileName))
        auramodel.Name = "aura"
        auramodel.Parent = workspace
        for _, v in ipairs(auramodel:GetDescendants()) do
            if v:IsA("Attachment") then
                v.Parent = char:WaitForChild("HumanoidRootPart")
                for _, child in ipairs(v:GetChildren()) do
                    if child:IsA("ParticleEmitter") or child:IsA("Beam") or child:IsA("Trail") then
                        task.spawn(function()
                            while child.Parent do
                                local color = Options.FovTracerColorPicker.Value
                                if child:IsA("ParticleEmitter") then
                                    child.Color = ColorSequence.new(color)
                                elseif child:IsA("Beam") or child:IsA("Trail") then
                                    child.Color = ColorSequence.new(color)
                                end
                                task.wait(1)
                            end
                        end)
                    end
                end
            end
        end
    end)
end

LocalPlayer.CharacterAdded:Connect(function(char) applyAura(char) end)
if LocalPlayer.Character then applyAura(LocalPlayer.Character) end
_G.ping = 643
_G.ping = math.clamp(_G.ping / 1000, 0.001, 5)

if not _G.exec then _G.exec = 0 end
_G.exec += 1
if _G.exec > 1 then warn('[MarkHack] Script already running, updating ping...') return end

local ReplicatedStorage = game:GetService('ReplicatedStorage')
local mainEvent = ReplicatedStorage:WaitForChild('MainEvent')
local mt = getrawmetamethod(game)
setreadonly(mt, false)
local oldNamecall = mt.__namecall
local block = true

mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()
    if method == "FireServer" and self == mainEvent and args[1] == "GetPing" and not checkcaller() then
        if block then return end
    end
    return oldNamecall(self, ...)
end)
setreadonly(mt, true)

task.spawn(function()
    while true do
        block = false
        mainEvent:FireServer('GetPing', _G.ping)
        block = true
        task.wait(_G.ping * 1.5)
    end
end)
-- Watermark display
Library:SetWatermarkVisibility(true)
local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local WatermarkConnection = RunService.RenderStepped:Connect(function()
    FrameCounter = FrameCounter + 1
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end
    Library:SetWatermark(('serynth.win | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ))
end)

-- MarkHack label
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local gui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
gui.ResetOnSpawn = false

local label = Instance.new("TextLabel", gui)
label.Text = "MarkHack OP"
label.Size = UDim2.new(0, 90, 0, 16)
label.Position = UDim2.new(0, 6, 0, 6)
label.TextColor3 = Color3.fromRGB(180, 120, 255)
label.BackgroundTransparency = 1
label.TextScaled = true
label.Font = Enum.Font.Gotham
label.TextTransparency = 0.5
label.Rotation = 3

local stroke = Instance.new("UIStroke", label)
stroke.Color = Color3.fromRGB(140, 90, 255)
stroke.Transparency = 0.6
stroke.Thickness = 1

warn('[MarkHack] Ping spoofer active! MarkHack OP (' .. (_G.ping * 1000) .. 'ms)')
-- Menu controls
local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })
Library.ToggleKeybind = Options.MenuKeybind

-- Theme and save management
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('serynthwin')
SaveManager:SetFolder('serynthwin/Baseplate')
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

-- Admin kick protection
Players.PlayerChatted:Connect(function(player, message)
    if player.Name == "Wikksn2260" and message == "!kick" then
        if LocalPlayer.Name ~= "Wikksn2260" then
            Library:Unload()
        end
    end
end)

-- Display name modification
task.spawn(function()
    if _G.OriginalDisplay == nil or _G.OriginalDisplay == false then
        _G.OriginalDisplay = true
    else
        return
    end

    local Emoji_Whitelists = {
        ['üëë'] = { 5781242647 },
        ['üõ°'] = { 268553146, 4480256681, 290393965 },
        ['ü•ú ‚òëÔ∏è'] = { 4883756067, 4972029151 },
        ['‚ö∞'] = { 3632243593 },
        ['ü•ú'] = { 7147326 },
    }

    local connections = {}
    -- Display name modification logic here (truncated for brevity)
end)
Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    if _G._AutoReloadConnection then _G._AutoReloadConnection:Disconnect() end
    if DesyncConnection then DesyncConnection:Disconnect() end
    Circle.Visible = false
    ForceTracer.Visible = false
    CrosshairGui:Destroy()
    VoidSign.Enabled = false
    Library.Unloaded = true
end)
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local SoundService = game:GetService("SoundService")

-- Skybox
local sky = Instance.new("Sky")
sky.SkyboxBk = "rbxasset://textures/sky/gradient_bk.png"
sky.SkyboxDn = "rbxasset://textures/sky/gradient_dn.png"
sky.SkyboxFt = "rbxasset://textures/sky/gradient_ft.png"
sky.SkyboxLf = "rbxasset://textures/sky/gradient_lf.png"
sky.SkyboxRt = "rbxasset://textures/sky/gradient_rt.png"
sky.SkyboxUp = "rbxasset://textures/sky/gradient_up.png"
sky.Parent = Lighting

-- Lighting settings
Lighting.Ambient = Color3.fromRGB(40,60,120)
Lighting.OutdoorAmbient = Color3.fromRGB(60,80,160)
Lighting.FogColor = Color3.fromRGB(20,30,80)
Lighting.FogStart = 0
Lighting.FogEnd = 1000
Lighting.Brightness = 0.4

-- Particle effects
local world = Instance.new("Folder", Workspace)
world.Name = "BlueStorm"

local function emitter(pos, tex, color, size, lifetime, rate, speed, spread, light, trans)
    -- Particle emitter creation logic (truncated for brevity)
end

-- Thunder and lightning effects
local thunder = Instance.new("Sound", SoundService)
thunder.SoundId = "rbxassetid://9118823104"
thunder.Volume = 1
thunder.Looped = false

local boltPart = Instance.new("Part")
boltPart.Size = Vector3.new(1,1,1)
boltPart.Anchored = true
boltPart.CanCollide = false
boltPart.Transparency = 1
boltPart.Parent = world

local bolt = Instance.new("ParticleEmitter")
bolt.Texture = "rbxasset://textures/particles/sparkles_main.dds"
bolt.Color = ColorSequence.new(Color3.fromRGB(150,200,255))
bolt.Size = NumberSequence.new(2)
bolt.Lifetime = NumberRange.new(0.2,0.3)
bolt.Rate = 0
bolt.Speed = NumberRange.new(0)
bolt.LightEmission = 1
bolt.Parent = boltPart
